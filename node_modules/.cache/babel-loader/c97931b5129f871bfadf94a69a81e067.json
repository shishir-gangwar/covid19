{"ast":null,"code":"import { select } from 'd3-selection';\nimport { format, formatLocale, formatPrefix, formatSpecifier } from 'd3-format';\nimport { dispatch } from 'd3-dispatch';\nimport { scaleLinear } from 'd3-scale';\nimport { max, sum } from 'd3-array';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar d3_identity = function d3_identity(d) {\n  return d;\n};\n\nvar d3_reverse = function d3_reverse(arr) {\n  var mirror = [];\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    mirror[i] = arr[l - i - 1];\n  }\n\n  return mirror;\n}; //Text wrapping code adapted from Mike Bostock\n\n\nvar d3_textWrapping = function d3_textWrapping(text, width) {\n  text.each(function () {\n    var text = select(this),\n        words = text.text().split(/\\s+/).reverse(),\n        word,\n        line = [],\n        lineNumber = 0,\n        lineHeight = 1.2,\n        //ems\n    y = text.attr(\"y\"),\n        dy = parseFloat(text.attr(\"dy\")) || 0,\n        tspan = text.text(null).append(\"tspan\").attr(\"x\", 0).attr(\"dy\", dy + \"em\");\n\n    while (word = words.pop()) {\n      line.push(word);\n      tspan.text(line.join(\" \"));\n\n      if (tspan.node().getComputedTextLength() > width && line.length > 1) {\n        line.pop();\n        tspan.text(line.join(\" \"));\n        line = [word];\n        tspan = text.append(\"tspan\").attr(\"x\", 0).attr(\"dy\", lineHeight + dy + \"em\").text(word);\n      }\n    }\n  });\n};\n\nvar d3_mergeLabels = function d3_mergeLabels() {\n  var gen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var labels = arguments[1];\n  var domain = arguments[2];\n  var range = arguments[3];\n  var labelDelimiter = arguments[4];\n\n  if ((typeof labels === \"undefined\" ? \"undefined\" : _typeof(labels)) === \"object\") {\n    if (labels.length === 0) return gen;\n    var i = labels.length;\n\n    for (; i < gen.length; i++) {\n      labels.push(gen[i]);\n    }\n\n    return labels;\n  } else if (typeof labels === \"function\") {\n    var customLabels = [];\n    var genLength = gen.length;\n\n    for (var _i = 0; _i < genLength; _i++) {\n      customLabels.push(labels({\n        i: _i,\n        genLength: genLength,\n        generatedLabels: gen,\n        domain: domain,\n        range: range,\n        labelDelimiter: labelDelimiter\n      }));\n    }\n\n    return customLabels;\n  }\n\n  return gen;\n};\n\nvar d3_linearLegend = function d3_linearLegend(scale, cells, labelFormat) {\n  var data = [];\n\n  if (cells.length > 1) {\n    data = cells;\n  } else {\n    var domain = scale.domain(),\n        increment = (domain[domain.length - 1] - domain[0]) / (cells - 1);\n    var i = 0;\n\n    for (; i < cells; i++) {\n      data.push(domain[0] + i * increment);\n    }\n  }\n\n  var labels = data.map(labelFormat);\n  return {\n    data: data,\n    labels: labels,\n    feature: function feature(d) {\n      return scale(d);\n    }\n  };\n};\n\nvar d3_quantLegend = function d3_quantLegend(scale, labelFormat, labelDelimiter) {\n  var labels = scale.range().map(function (d) {\n    var invert = scale.invertExtent(d);\n    return labelFormat(invert[0]) + \" \" + labelDelimiter + \" \" + labelFormat(invert[1]);\n  });\n  return {\n    data: scale.range(),\n    labels: labels,\n    feature: d3_identity\n  };\n};\n\nvar d3_ordinalLegend = function d3_ordinalLegend(scale) {\n  return {\n    data: scale.domain(),\n    labels: scale.domain(),\n    feature: function feature(d) {\n      return scale(d);\n    }\n  };\n};\n\nvar d3_cellOver = function d3_cellOver(cellDispatcher, d, obj) {\n  cellDispatcher.call(\"cellover\", obj, d);\n};\n\nvar d3_cellOut = function d3_cellOut(cellDispatcher, d, obj) {\n  cellDispatcher.call(\"cellout\", obj, d);\n};\n\nvar d3_cellClick = function d3_cellClick(cellDispatcher, d, obj) {\n  cellDispatcher.call(\"cellclick\", obj, d);\n};\n\nvar helper = {\n  d3_drawShapes: function d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path) {\n    if (shape === \"rect\") {\n      shapes.attr(\"height\", shapeHeight).attr(\"width\", shapeWidth);\n    } else if (shape === \"circle\") {\n      shapes.attr(\"r\", shapeRadius);\n    } else if (shape === \"line\") {\n      shapes.attr(\"x1\", 0).attr(\"x2\", shapeWidth).attr(\"y1\", 0).attr(\"y2\", 0);\n    } else if (shape === \"path\") {\n      shapes.attr(\"d\", path);\n    }\n  },\n  d3_addText: function d3_addText(svg, enter, labels, classPrefix, labelWidth) {\n    enter.append(\"text\").attr(\"class\", classPrefix + \"label\");\n    var text = svg.selectAll(\"g.\" + classPrefix + \"cell text.\" + classPrefix + \"label\").data(labels).text(d3_identity);\n\n    if (labelWidth) {\n      svg.selectAll(\"g.\" + classPrefix + \"cell text.\" + classPrefix + \"label\").call(d3_textWrapping, labelWidth);\n    }\n\n    return text;\n  },\n  d3_calcType: function d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter) {\n    var type = scale.invertExtent ? d3_quantLegend(scale, labelFormat, labelDelimiter) : scale.ticks ? d3_linearLegend(scale, cells, labelFormat) : d3_ordinalLegend(scale); //for d3.scaleSequential that doesn't have a range function\n\n    var range = scale.range && scale.range() || scale.domain();\n    type.labels = d3_mergeLabels(type.labels, labels, scale.domain(), range, labelDelimiter);\n\n    if (ascending) {\n      type.labels = d3_reverse(type.labels);\n      type.data = d3_reverse(type.data);\n    }\n\n    return type;\n  },\n  d3_filterCells: function d3_filterCells(type, cellFilter) {\n    var filterCells = type.data.map(function (d, i) {\n      return {\n        data: d,\n        label: type.labels[i]\n      };\n    }).filter(cellFilter);\n    var dataValues = filterCells.map(function (d) {\n      return d.data;\n    });\n    var labelValues = filterCells.map(function (d) {\n      return d.label;\n    });\n    type.data = type.data.filter(function (d) {\n      return dataValues.indexOf(d) !== -1;\n    });\n    type.labels = type.labels.filter(function (d) {\n      return labelValues.indexOf(d) !== -1;\n    });\n    return type;\n  },\n  d3_placement: function d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign) {\n    cell.attr(\"transform\", cellTrans);\n    text.attr(\"transform\", textTrans);\n\n    if (orient === \"horizontal\") {\n      text.style(\"text-anchor\", labelAlign);\n    }\n  },\n  d3_addEvents: function d3_addEvents(cells, dispatcher) {\n    cells.on(\"mouseover.legend\", function (d) {\n      d3_cellOver(dispatcher, d, this);\n    }).on(\"mouseout.legend\", function (d) {\n      d3_cellOut(dispatcher, d, this);\n    }).on(\"click.legend\", function (d) {\n      d3_cellClick(dispatcher, d, this);\n    });\n  },\n  d3_title: function d3_title(svg, title, classPrefix, titleWidth) {\n    if (title !== \"\") {\n      var titleText = svg.selectAll(\"text.\" + classPrefix + \"legendTitle\");\n      titleText.data([title]).enter().append(\"text\").attr(\"class\", classPrefix + \"legendTitle\");\n      svg.selectAll(\"text.\" + classPrefix + \"legendTitle\").text(title);\n\n      if (titleWidth) {\n        svg.selectAll(\"text.\" + classPrefix + \"legendTitle\").call(d3_textWrapping, titleWidth);\n      }\n\n      var cellsSvg = svg.select(\".\" + classPrefix + \"legendCells\");\n      var yOffset = svg.select(\".\" + classPrefix + \"legendTitle\").nodes().map(function (d) {\n        return d.getBBox().height;\n      })[0],\n          xOffset = -cellsSvg.nodes().map(function (d) {\n        return d.getBBox().x;\n      })[0];\n      cellsSvg.attr(\"transform\", \"translate(\" + xOffset + \",\" + yOffset + \")\");\n    }\n  },\n  d3_defaultLocale: {\n    format: format,\n    formatPrefix: formatPrefix\n  },\n  d3_defaultFormatSpecifier: \".01f\",\n  d3_defaultDelimiter: \"to\"\n};\n\nfunction color() {\n  var scale = scaleLinear(),\n      shape = \"rect\",\n      shapeWidth = 15,\n      shapeHeight = 15,\n      shapeRadius = 10,\n      shapePadding = 2,\n      cells = [5],\n      cellFilter = void 0,\n      labels = [],\n      classPrefix = \"\",\n      useClass = false,\n      title = \"\",\n      locale = helper.d3_defaultLocale,\n      specifier = helper.d3_defaultFormatSpecifier,\n      labelOffset = 10,\n      labelAlign = \"middle\",\n      labelDelimiter = helper.d3_defaultDelimiter,\n      labelWrap = void 0,\n      orient = \"vertical\",\n      ascending = false,\n      path = void 0,\n      titleWidth = void 0,\n      legendDispatcher = dispatch(\"cellover\", \"cellout\", \"cellclick\");\n\n  function legend(svg) {\n    var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),\n        legendG = svg.selectAll(\"g\").data([scale]);\n    legendG.enter().append(\"g\").attr(\"class\", classPrefix + \"legendCells\");\n\n    if (cellFilter) {\n      helper.d3_filterCells(type, cellFilter);\n    }\n\n    var cell = svg.select(\".\" + classPrefix + \"legendCells\").selectAll(\".\" + classPrefix + \"cell\").data(type.data);\n    var cellEnter = cell.enter().append(\"g\").attr(\"class\", classPrefix + \"cell\");\n    cellEnter.append(shape).attr(\"class\", classPrefix + \"swatch\");\n    var shapes = svg.selectAll(\"g.\" + classPrefix + \"cell \" + shape + \".\" + classPrefix + \"swatch\").data(type.data); //add event handlers\n\n    helper.d3_addEvents(cellEnter, legendDispatcher);\n    cell.exit().transition().style(\"opacity\", 0).remove();\n    shapes.exit().transition().style(\"opacity\", 0).remove();\n    shapes = shapes.merge(shapes);\n    helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path);\n    var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap); // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.\n\n    cell = cellEnter.merge(cell); // sets placement\n\n    var textSize = text.nodes().map(function (d) {\n      return d.getBBox();\n    }),\n        shapeSize = shapes.nodes().map(function (d) {\n      return d.getBBox();\n    }); //sets scale\n    //everything is fill except for line which is stroke,\n\n    if (!useClass) {\n      if (shape == \"line\") {\n        shapes.style(\"stroke\", type.feature);\n      } else {\n        shapes.style(\"fill\", type.feature);\n      }\n    } else {\n      shapes.attr(\"class\", function (d) {\n        return classPrefix + \"swatch \" + type.feature(d);\n      });\n    }\n\n    var cellTrans = void 0,\n        textTrans = void 0,\n        textAlign = labelAlign == \"start\" ? 0 : labelAlign == \"middle\" ? 0.5 : 1; //positions cells and text\n\n    if (orient === \"vertical\") {\n      (function () {\n        var cellSize = textSize.map(function (d, i) {\n          return Math.max(d.height, shapeSize[i].height);\n        });\n\n        cellTrans = function cellTrans(d, i) {\n          var height = sum(cellSize.slice(0, i));\n          return \"translate(0, \" + (height + i * shapePadding) + \")\";\n        };\n\n        textTrans = function textTrans(d, i) {\n          return \"translate( \" + (shapeSize[i].width + shapeSize[i].x + labelOffset) + \", \" + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + \")\";\n        };\n      })();\n    } else if (orient === \"horizontal\") {\n      cellTrans = function cellTrans(d, i) {\n        return \"translate(\" + i * (shapeSize[i].width + shapePadding) + \",0)\";\n      };\n\n      textTrans = function textTrans(d, i) {\n        return \"translate(\" + (shapeSize[i].width * textAlign + shapeSize[i].x) + \",\\n          \" + (shapeSize[i].height + shapeSize[i].y + labelOffset + 8) + \")\";\n      };\n    }\n\n    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);\n    helper.d3_title(svg, title, classPrefix, titleWidth);\n    cell.transition().style(\"opacity\", 1);\n  }\n\n  legend.scale = function (_) {\n    if (!arguments.length) return scale;\n    scale = _;\n    return legend;\n  };\n\n  legend.cells = function (_) {\n    if (!arguments.length) return cells;\n\n    if (_.length > 1 || _ >= 2) {\n      cells = _;\n    }\n\n    return legend;\n  };\n\n  legend.cellFilter = function (_) {\n    if (!arguments.length) return cellFilter;\n    cellFilter = _;\n    return legend;\n  };\n\n  legend.shape = function (_, d) {\n    if (!arguments.length) return shape;\n\n    if (_ == \"rect\" || _ == \"circle\" || _ == \"line\" || _ == \"path\" && typeof d === \"string\") {\n      shape = _;\n      path = d;\n    }\n\n    return legend;\n  };\n\n  legend.shapeWidth = function (_) {\n    if (!arguments.length) return shapeWidth;\n    shapeWidth = +_;\n    return legend;\n  };\n\n  legend.shapeHeight = function (_) {\n    if (!arguments.length) return shapeHeight;\n    shapeHeight = +_;\n    return legend;\n  };\n\n  legend.shapeRadius = function (_) {\n    if (!arguments.length) return shapeRadius;\n    shapeRadius = +_;\n    return legend;\n  };\n\n  legend.shapePadding = function (_) {\n    if (!arguments.length) return shapePadding;\n    shapePadding = +_;\n    return legend;\n  };\n\n  legend.labels = function (_) {\n    if (!arguments.length) return labels;\n    labels = _;\n    return legend;\n  };\n\n  legend.labelAlign = function (_) {\n    if (!arguments.length) return labelAlign;\n\n    if (_ == \"start\" || _ == \"end\" || _ == \"middle\") {\n      labelAlign = _;\n    }\n\n    return legend;\n  };\n\n  legend.locale = function (_) {\n    if (!arguments.length) return locale;\n    locale = formatLocale(_);\n    return legend;\n  };\n\n  legend.labelFormat = function (_) {\n    if (!arguments.length) return legend.locale().format(specifier);\n    specifier = formatSpecifier(_);\n    return legend;\n  };\n\n  legend.labelOffset = function (_) {\n    if (!arguments.length) return labelOffset;\n    labelOffset = +_;\n    return legend;\n  };\n\n  legend.labelDelimiter = function (_) {\n    if (!arguments.length) return labelDelimiter;\n    labelDelimiter = _;\n    return legend;\n  };\n\n  legend.labelWrap = function (_) {\n    if (!arguments.length) return labelWrap;\n    labelWrap = _;\n    return legend;\n  };\n\n  legend.useClass = function (_) {\n    if (!arguments.length) return useClass;\n\n    if (_ === true || _ === false) {\n      useClass = _;\n    }\n\n    return legend;\n  };\n\n  legend.orient = function (_) {\n    if (!arguments.length) return orient;\n    _ = _.toLowerCase();\n\n    if (_ == \"horizontal\" || _ == \"vertical\") {\n      orient = _;\n    }\n\n    return legend;\n  };\n\n  legend.ascending = function (_) {\n    if (!arguments.length) return ascending;\n    ascending = !!_;\n    return legend;\n  };\n\n  legend.classPrefix = function (_) {\n    if (!arguments.length) return classPrefix;\n    classPrefix = _;\n    return legend;\n  };\n\n  legend.title = function (_) {\n    if (!arguments.length) return title;\n    title = _;\n    return legend;\n  };\n\n  legend.titleWidth = function (_) {\n    if (!arguments.length) return titleWidth;\n    titleWidth = _;\n    return legend;\n  };\n\n  legend.textWrap = function (_) {\n    if (!arguments.length) return textWrap;\n    textWrap = _;\n    return legend;\n  };\n\n  legend.on = function () {\n    var value = legendDispatcher.on.apply(legendDispatcher, arguments);\n    return value === legendDispatcher ? legend : value;\n  };\n\n  return legend;\n}\n\nfunction size() {\n  var scale = scaleLinear(),\n      shape = \"rect\",\n      shapeWidth = 15,\n      shapePadding = 2,\n      cells = [5],\n      cellFilter = void 0,\n      labels = [],\n      classPrefix = \"\",\n      title = \"\",\n      locale = helper.d3_defaultLocale,\n      specifier = helper.d3_defaultFormatSpecifier,\n      labelOffset = 10,\n      labelAlign = \"middle\",\n      labelDelimiter = helper.d3_defaultDelimiter,\n      labelWrap = void 0,\n      orient = \"vertical\",\n      ascending = false,\n      path = void 0,\n      titleWidth = void 0,\n      legendDispatcher = dispatch(\"cellover\", \"cellout\", \"cellclick\");\n\n  function legend(svg) {\n    var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),\n        legendG = svg.selectAll(\"g\").data([scale]);\n\n    if (cellFilter) {\n      helper.d3_filterCells(type, cellFilter);\n    }\n\n    legendG.enter().append(\"g\").attr(\"class\", classPrefix + \"legendCells\");\n    var cell = svg.select(\".\" + classPrefix + \"legendCells\").selectAll(\".\" + classPrefix + \"cell\").data(type.data);\n    var cellEnter = cell.enter().append(\"g\").attr(\"class\", classPrefix + \"cell\");\n    cellEnter.append(shape).attr(\"class\", classPrefix + \"swatch\");\n    var shapes = svg.selectAll(\"g.\" + classPrefix + \"cell \" + shape + \".\" + classPrefix + \"swatch\"); //add event handlers\n\n    helper.d3_addEvents(cellEnter, legendDispatcher);\n    cell.exit().transition().style(\"opacity\", 0).remove();\n    shapes.exit().transition().style(\"opacity\", 0).remove();\n    shapes = shapes.merge(shapes); //creates shape\n\n    if (shape === \"line\") {\n      helper.d3_drawShapes(shape, shapes, 0, shapeWidth);\n      shapes.attr(\"stroke-width\", type.feature);\n    } else {\n      helper.d3_drawShapes(shape, shapes, type.feature, type.feature, type.feature, path);\n    }\n\n    var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap); // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.\n\n    cell = cellEnter.merge(cell); //sets placement\n\n    var textSize = text.nodes().map(function (d) {\n      return d.getBBox();\n    }),\n        shapeSize = shapes.nodes().map(function (d, i) {\n      var bbox = d.getBBox();\n      var stroke = scale(type.data[i]);\n\n      if (shape === \"line\" && orient === \"horizontal\") {\n        bbox.height = bbox.height + stroke;\n      } else if (shape === \"line\" && orient === \"vertical\") {\n        bbox.width = bbox.width;\n      }\n\n      return bbox;\n    });\n    var maxH = max(shapeSize, function (d) {\n      return d.height + d.y;\n    }),\n        maxW = max(shapeSize, function (d) {\n      return d.width + d.x;\n    });\n    var cellTrans = void 0,\n        textTrans = void 0,\n        textAlign = labelAlign == \"start\" ? 0 : labelAlign == \"middle\" ? 0.5 : 1; //positions cells and text\n\n    if (orient === \"vertical\") {\n      (function () {\n        var cellSize = textSize.map(function (d, i) {\n          return Math.max(d.height, shapeSize[i].height);\n        });\n        var y = shape == \"circle\" || shape == \"line\" ? shapeSize[0].height / 2 : 0;\n\n        cellTrans = function cellTrans(d, i) {\n          var height = sum(cellSize.slice(0, i));\n          return \"translate(0, \" + (y + height + i * shapePadding) + \")\";\n        };\n\n        textTrans = function textTrans(d, i) {\n          return \"translate( \" + (maxW + labelOffset) + \",\\n          \" + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + \")\";\n        };\n      })();\n    } else if (orient === \"horizontal\") {\n      (function () {\n        cellTrans = function cellTrans(d, i) {\n          var width = sum(shapeSize.slice(0, i), function (d) {\n            return d.width;\n          });\n          var y = shape == \"circle\" || shape == \"line\" ? maxH / 2 : 0;\n          return \"translate(\" + (width + i * shapePadding) + \", \" + y + \")\";\n        };\n\n        var offset = shape == \"line\" ? maxH / 2 : maxH;\n\n        textTrans = function textTrans(d, i) {\n          return \"translate( \" + (shapeSize[i].width * textAlign + shapeSize[i].x) + \",\\n              \" + (offset + labelOffset) + \")\";\n        };\n      })();\n    }\n\n    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);\n    helper.d3_title(svg, title, classPrefix, titleWidth);\n    cell.transition().style(\"opacity\", 1);\n  }\n\n  legend.scale = function (_) {\n    if (!arguments.length) return scale;\n    scale = _;\n    return legend;\n  };\n\n  legend.cells = function (_) {\n    if (!arguments.length) return cells;\n\n    if (_.length > 1 || _ >= 2) {\n      cells = _;\n    }\n\n    return legend;\n  };\n\n  legend.cellFilter = function (_) {\n    if (!arguments.length) return cellFilter;\n    cellFilter = _;\n    return legend;\n  };\n\n  legend.shape = function (_, d) {\n    if (!arguments.length) return shape;\n\n    if (_ == \"rect\" || _ == \"circle\" || _ == \"line\") {\n      shape = _;\n      path = d;\n    }\n\n    return legend;\n  };\n\n  legend.shapeWidth = function (_) {\n    if (!arguments.length) return shapeWidth;\n    shapeWidth = +_;\n    return legend;\n  };\n\n  legend.shapePadding = function (_) {\n    if (!arguments.length) return shapePadding;\n    shapePadding = +_;\n    return legend;\n  };\n\n  legend.labels = function (_) {\n    if (!arguments.length) return labels;\n    labels = _;\n    return legend;\n  };\n\n  legend.labelAlign = function (_) {\n    if (!arguments.length) return labelAlign;\n\n    if (_ == \"start\" || _ == \"end\" || _ == \"middle\") {\n      labelAlign = _;\n    }\n\n    return legend;\n  };\n\n  legend.locale = function (_) {\n    if (!arguments.length) return locale;\n    locale = formatLocale(_);\n    return legend;\n  };\n\n  legend.labelFormat = function (_) {\n    if (!arguments.length) return legend.locale().format(specifier);\n    specifier = formatSpecifier(_);\n    return legend;\n  };\n\n  legend.labelOffset = function (_) {\n    if (!arguments.length) return labelOffset;\n    labelOffset = +_;\n    return legend;\n  };\n\n  legend.labelDelimiter = function (_) {\n    if (!arguments.length) return labelDelimiter;\n    labelDelimiter = _;\n    return legend;\n  };\n\n  legend.labelWrap = function (_) {\n    if (!arguments.length) return labelWrap;\n    labelWrap = _;\n    return legend;\n  };\n\n  legend.orient = function (_) {\n    if (!arguments.length) return orient;\n    _ = _.toLowerCase();\n\n    if (_ == \"horizontal\" || _ == \"vertical\") {\n      orient = _;\n    }\n\n    return legend;\n  };\n\n  legend.ascending = function (_) {\n    if (!arguments.length) return ascending;\n    ascending = !!_;\n    return legend;\n  };\n\n  legend.classPrefix = function (_) {\n    if (!arguments.length) return classPrefix;\n    classPrefix = _;\n    return legend;\n  };\n\n  legend.title = function (_) {\n    if (!arguments.length) return title;\n    title = _;\n    return legend;\n  };\n\n  legend.titleWidth = function (_) {\n    if (!arguments.length) return titleWidth;\n    titleWidth = _;\n    return legend;\n  };\n\n  legend.on = function () {\n    var value = legendDispatcher.on.apply(legendDispatcher, arguments);\n    return value === legendDispatcher ? legend : value;\n  };\n\n  return legend;\n}\n\nfunction symbol() {\n  var scale = scaleLinear(),\n      shape = \"path\",\n      shapeWidth = 15,\n      shapeHeight = 15,\n      shapeRadius = 10,\n      shapePadding = 5,\n      cells = [5],\n      cellFilter = void 0,\n      labels = [],\n      classPrefix = \"\",\n      title = \"\",\n      locale = helper.d3_defaultLocale,\n      specifier = helper.d3_defaultFormatSpecifier,\n      labelAlign = \"middle\",\n      labelOffset = 10,\n      labelDelimiter = helper.d3_defaultDelimiter,\n      labelWrap = void 0,\n      orient = \"vertical\",\n      ascending = false,\n      titleWidth = void 0,\n      legendDispatcher = dispatch(\"cellover\", \"cellout\", \"cellclick\");\n\n  function legend(svg) {\n    var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),\n        legendG = svg.selectAll(\"g\").data([scale]);\n\n    if (cellFilter) {\n      helper.d3_filterCells(type, cellFilter);\n    }\n\n    legendG.enter().append(\"g\").attr(\"class\", classPrefix + \"legendCells\");\n    var cell = svg.select(\".\" + classPrefix + \"legendCells\").selectAll(\".\" + classPrefix + \"cell\").data(type.data);\n    var cellEnter = cell.enter().append(\"g\").attr(\"class\", classPrefix + \"cell\");\n    cellEnter.append(shape).attr(\"class\", classPrefix + \"swatch\");\n    var shapes = svg.selectAll(\"g.\" + classPrefix + \"cell \" + shape + \".\" + classPrefix + \"swatch\"); //add event handlers\n\n    helper.d3_addEvents(cellEnter, legendDispatcher); //remove old shapes\n\n    cell.exit().transition().style(\"opacity\", 0).remove();\n    shapes.exit().transition().style(\"opacity\", 0).remove();\n    shapes = shapes.merge(shapes);\n    helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, type.feature);\n    var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap); // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.\n\n    cell = cellEnter.merge(cell); // sets placement\n\n    var textSize = text.nodes().map(function (d) {\n      return d.getBBox();\n    }),\n        shapeSize = shapes.nodes().map(function (d) {\n      return d.getBBox();\n    });\n    var maxH = max(shapeSize, function (d) {\n      return d.height;\n    }),\n        maxW = max(shapeSize, function (d) {\n      return d.width;\n    });\n    var cellTrans = void 0,\n        textTrans = void 0,\n        textAlign = labelAlign == \"start\" ? 0 : labelAlign == \"middle\" ? 0.5 : 1; //positions cells and text\n\n    if (orient === \"vertical\") {\n      (function () {\n        var cellSize = textSize.map(function (d, i) {\n          return Math.max(maxH, d.height);\n        });\n\n        cellTrans = function cellTrans(d, i) {\n          var height = sum(cellSize.slice(0, i));\n          return \"translate(0, \" + (height + i * shapePadding) + \" )\";\n        };\n\n        textTrans = function textTrans(d, i) {\n          return \"translate( \" + (maxW + labelOffset) + \",\\n              \" + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + \")\";\n        };\n      })();\n    } else if (orient === \"horizontal\") {\n      cellTrans = function cellTrans(d, i) {\n        return \"translate( \" + i * (maxW + shapePadding) + \",0)\";\n      };\n\n      textTrans = function textTrans(d, i) {\n        return \"translate( \" + (shapeSize[i].width * textAlign + shapeSize[i].x) + \",\\n              \" + (maxH + labelOffset) + \")\";\n      };\n    }\n\n    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);\n    helper.d3_title(svg, title, classPrefix, titleWidth);\n    cell.transition().style(\"opacity\", 1);\n  }\n\n  legend.scale = function (_) {\n    if (!arguments.length) return scale;\n    scale = _;\n    return legend;\n  };\n\n  legend.cells = function (_) {\n    if (!arguments.length) return cells;\n\n    if (_.length > 1 || _ >= 2) {\n      cells = _;\n    }\n\n    return legend;\n  };\n\n  legend.cellFilter = function (_) {\n    if (!arguments.length) return cellFilter;\n    cellFilter = _;\n    return legend;\n  };\n\n  legend.shapePadding = function (_) {\n    if (!arguments.length) return shapePadding;\n    shapePadding = +_;\n    return legend;\n  };\n\n  legend.labels = function (_) {\n    if (!arguments.length) return labels;\n    labels = _;\n    return legend;\n  };\n\n  legend.labelAlign = function (_) {\n    if (!arguments.length) return labelAlign;\n\n    if (_ == \"start\" || _ == \"end\" || _ == \"middle\") {\n      labelAlign = _;\n    }\n\n    return legend;\n  };\n\n  legend.locale = function (_) {\n    if (!arguments.length) return locale;\n    locale = formatLocale(_);\n    return legend;\n  };\n\n  legend.labelFormat = function (_) {\n    if (!arguments.length) return legend.locale().format(specifier);\n    specifier = formatSpecifier(_);\n    return legend;\n  };\n\n  legend.labelOffset = function (_) {\n    if (!arguments.length) return labelOffset;\n    labelOffset = +_;\n    return legend;\n  };\n\n  legend.labelDelimiter = function (_) {\n    if (!arguments.length) return labelDelimiter;\n    labelDelimiter = _;\n    return legend;\n  };\n\n  legend.labelWrap = function (_) {\n    if (!arguments.length) return labelWrap;\n    labelWrap = _;\n    return legend;\n  };\n\n  legend.orient = function (_) {\n    if (!arguments.length) return orient;\n    _ = _.toLowerCase();\n\n    if (_ == \"horizontal\" || _ == \"vertical\") {\n      orient = _;\n    }\n\n    return legend;\n  };\n\n  legend.ascending = function (_) {\n    if (!arguments.length) return ascending;\n    ascending = !!_;\n    return legend;\n  };\n\n  legend.classPrefix = function (_) {\n    if (!arguments.length) return classPrefix;\n    classPrefix = _;\n    return legend;\n  };\n\n  legend.title = function (_) {\n    if (!arguments.length) return title;\n    title = _;\n    return legend;\n  };\n\n  legend.titleWidth = function (_) {\n    if (!arguments.length) return titleWidth;\n    titleWidth = _;\n    return legend;\n  };\n\n  legend.on = function () {\n    var value = legendDispatcher.on.apply(legendDispatcher, arguments);\n    return value === legendDispatcher ? legend : value;\n  };\n\n  return legend;\n}\n\nvar thresholdLabels = function thresholdLabels(_ref) {\n  var i = _ref.i,\n      genLength = _ref.genLength,\n      generatedLabels = _ref.generatedLabels,\n      labelDelimiter = _ref.labelDelimiter;\n\n  if (i === 0) {\n    var values = generatedLabels[i].split(\" \" + labelDelimiter + \" \");\n    return \"Less than \" + values[1];\n  } else if (i === genLength - 1) {\n    var _values = generatedLabels[i].split(\" \" + labelDelimiter + \" \");\n\n    return _values[0] + \" or more\";\n  }\n\n  return generatedLabels[i];\n};\n\nvar legendHelpers = {\n  thresholdLabels: thresholdLabels\n};\nvar index = {\n  legendColor: color,\n  legendSize: size,\n  legendSymbol: symbol,\n  legendHelpers: legendHelpers\n};\nexport { color as legendColor, size as legendSize, symbol as legendSymbol, legendHelpers };\nexport default index;","map":{"version":3,"sources":["src/legend.js","src/color.js","src/size.js","src/symbol.js","src/helpers.js","index.js"],"names":["d3_identity","d3_reverse","mirror","i","l","arr","d3_textWrapping","text","select","words","line","lineNumber","lineHeight","dy","parseFloat","tspan","word","d3_mergeLabels","gen","labels","domain","range","labelDelimiter","customLabels","genLength","d3_linearLegend","data","cells","scale","increment","d3_quantLegend","invert","labelFormat","d3_ordinalLegend","d3_cellOver","d3_cellOut","d3_cellClick","shape","classPrefix","svg","type","filterCells","label","dataValues","d","labelValues","orient","title","titleText","cellsSvg","yOffset","xOffset","scaleLinear","shapeWidth","shapeHeight","shapeRadius","shapePadding","cellFilter","useClass","locale","helper","specifier","labelOffset","labelAlign","labelWrap","ascending","path","titleWidth","legendDispatcher","dispatch","legendG","cell","cellEnter","shapes","textSize","shapeSize","cellTrans","textTrans","textAlign","cellSize","Math","height","sum","arguments","_","formatLocale","legend","formatSpecifier","value","bbox","stroke","maxH","maxW","y","width","offset","thresholdLabels","generatedLabels","values"],"mappings":"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","sourcesContent":["import { select } from \"d3-selection\"\nimport { format, formatPrefix } from \"d3-format\"\n\nconst d3_identity = d => d\n\nconst d3_reverse = arr => {\n  const mirror = []\n  for (let i = 0, l = arr.length; i < l; i++) {\n    mirror[i] = arr[l - i - 1]\n  }\n  return mirror\n}\n\n//Text wrapping code adapted from Mike Bostock\nconst d3_textWrapping = (text, width) => {\n  text.each(function() {\n    var text = select(this),\n      words = text\n        .text()\n        .split(/\\s+/)\n        .reverse(),\n      word,\n      line = [],\n      lineNumber = 0,\n      lineHeight = 1.2, //ems\n      y = text.attr(\"y\"),\n      dy = parseFloat(text.attr(\"dy\")) || 0,\n      tspan = text\n        .text(null)\n        .append(\"tspan\")\n        .attr(\"x\", 0)\n        .attr(\"dy\", dy + \"em\")\n\n    while ((word = words.pop())) {\n      line.push(word)\n      tspan.text(line.join(\" \"))\n      if (tspan.node().getComputedTextLength() > width && line.length > 1) {\n        line.pop()\n        tspan.text(line.join(\" \"))\n        line = [word]\n        tspan = text\n          .append(\"tspan\")\n          .attr(\"x\", 0)\n          .attr(\"dy\", lineHeight + dy + \"em\")\n          .text(word)\n      }\n    }\n  })\n}\n\nconst d3_mergeLabels = (gen = [], labels, domain, range, labelDelimiter) => {\n  if (typeof labels === \"object\") {\n    if (labels.length === 0) return gen\n\n    let i = labels.length\n    for (; i < gen.length; i++) {\n      labels.push(gen[i])\n    }\n    return labels\n  } else if (typeof labels === \"function\") {\n    const customLabels = []\n    const genLength = gen.length\n    for (let i = 0; i < genLength; i++) {\n      customLabels.push(\n        labels({\n          i,\n          genLength,\n          generatedLabels: gen,\n          domain,\n          range,\n          labelDelimiter\n        })\n      )\n    }\n    return customLabels\n  }\n\n  return gen\n}\n\nconst d3_linearLegend = (scale, cells, labelFormat) => {\n  let data = []\n\n  if (cells.length > 1) {\n    data = cells\n  } else {\n    const domain = scale.domain(),\n      increment = (domain[domain.length - 1] - domain[0]) / (cells - 1)\n    let i = 0\n\n    for (; i < cells; i++) {\n      data.push(domain[0] + i * increment)\n    }\n  }\n\n  const labels = data.map(labelFormat)\n  return {\n    data: data,\n    labels: labels,\n    feature: d => scale(d)\n  }\n}\n\nconst d3_quantLegend = (scale, labelFormat, labelDelimiter) => {\n  const labels = scale.range().map(d => {\n    const invert = scale.invertExtent(d)\n    return (\n      labelFormat(invert[0]) +\n      \" \" +\n      labelDelimiter +\n      \" \" +\n      labelFormat(invert[1])\n    )\n  })\n\n  return {\n    data: scale.range(),\n    labels: labels,\n    feature: d3_identity\n  }\n}\n\nconst d3_ordinalLegend = scale => ({\n  data: scale.domain(),\n  labels: scale.domain(),\n  feature: d => scale(d)\n})\n\nconst d3_cellOver = (cellDispatcher, d, obj) => {\n  cellDispatcher.call(\"cellover\", obj, d)\n}\n\nconst d3_cellOut = (cellDispatcher, d, obj) => {\n  cellDispatcher.call(\"cellout\", obj, d)\n}\n\nconst d3_cellClick = (cellDispatcher, d, obj) => {\n  cellDispatcher.call(\"cellclick\", obj, d)\n}\n\nexport default {\n  d3_drawShapes: (\n    shape,\n    shapes,\n    shapeHeight,\n    shapeWidth,\n    shapeRadius,\n    path\n  ) => {\n    if (shape === \"rect\") {\n      shapes.attr(\"height\", shapeHeight).attr(\"width\", shapeWidth)\n    } else if (shape === \"circle\") {\n      shapes.attr(\"r\", shapeRadius)\n    } else if (shape === \"line\") {\n      shapes\n        .attr(\"x1\", 0)\n        .attr(\"x2\", shapeWidth)\n        .attr(\"y1\", 0)\n        .attr(\"y2\", 0)\n    } else if (shape === \"path\") {\n      shapes.attr(\"d\", path)\n    }\n  },\n\n  d3_addText: function(svg, enter, labels, classPrefix, labelWidth) {\n    enter.append(\"text\").attr(\"class\", classPrefix + \"label\")\n    const text = svg\n      .selectAll(`g.${classPrefix}cell text.${classPrefix}label`)\n      .data(labels)\n      .text(d3_identity)\n\n    if (labelWidth) {\n      svg\n        .selectAll(`g.${classPrefix}cell text.${classPrefix}label`)\n        .call(d3_textWrapping, labelWidth)\n    }\n\n    return text\n  },\n\n  d3_calcType: function(\n    scale,\n    ascending,\n    cells,\n    labels,\n    labelFormat,\n    labelDelimiter\n  ) {\n    const type = scale.invertExtent\n      ? d3_quantLegend(scale, labelFormat, labelDelimiter)\n      : scale.ticks\n        ? d3_linearLegend(scale, cells, labelFormat)\n        : d3_ordinalLegend(scale)\n\n    //for d3.scaleSequential that doesn't have a range function\n    const range = (scale.range && scale.range()) || scale.domain()\n    type.labels = d3_mergeLabels(\n      type.labels,\n      labels,\n      scale.domain(),\n      range,\n      labelDelimiter\n    )\n\n    if (ascending) {\n      type.labels = d3_reverse(type.labels)\n      type.data = d3_reverse(type.data)\n    }\n\n    return type\n  },\n\n  d3_filterCells: (type, cellFilter) => {\n    let filterCells = type.data\n      .map((d, i) => ({ data: d, label: type.labels[i] }))\n      .filter(cellFilter)\n    const dataValues = filterCells.map(d => d.data)\n    const labelValues = filterCells.map(d => d.label)\n    type.data = type.data.filter(d => dataValues.indexOf(d) !== -1)\n    type.labels = type.labels.filter(d => labelValues.indexOf(d) !== -1)\n    return type\n  },\n\n  d3_placement: (orient, cell, cellTrans, text, textTrans, labelAlign) => {\n    cell.attr(\"transform\", cellTrans)\n    text.attr(\"transform\", textTrans)\n    if (orient === \"horizontal\") {\n      text.style(\"text-anchor\", labelAlign)\n    }\n  },\n\n  d3_addEvents: function(cells, dispatcher) {\n    cells\n      .on(\"mouseover.legend\", function(d) {\n        d3_cellOver(dispatcher, d, this)\n      })\n      .on(\"mouseout.legend\", function(d) {\n        d3_cellOut(dispatcher, d, this)\n      })\n      .on(\"click.legend\", function(d) {\n        d3_cellClick(dispatcher, d, this)\n      })\n  },\n\n  d3_title: (svg, title, classPrefix, titleWidth) => {\n    if (title !== \"\") {\n      const titleText = svg.selectAll(\"text.\" + classPrefix + \"legendTitle\")\n\n      titleText\n        .data([title])\n        .enter()\n        .append(\"text\")\n        .attr(\"class\", classPrefix + \"legendTitle\")\n\n      svg.selectAll(\"text.\" + classPrefix + \"legendTitle\").text(title)\n\n      if (titleWidth) {\n        svg\n          .selectAll(\"text.\" + classPrefix + \"legendTitle\")\n          .call(d3_textWrapping, titleWidth)\n      }\n\n      const cellsSvg = svg.select(\".\" + classPrefix + \"legendCells\")\n      const yOffset = svg\n          .select(\".\" + classPrefix + \"legendTitle\")\n          .nodes()\n          .map(d => d.getBBox().height)[0],\n        xOffset = -cellsSvg.nodes().map(function(d) {\n          return d.getBBox().x\n        })[0]\n      cellsSvg.attr(\"transform\", \"translate(\" + xOffset + \",\" + yOffset + \")\")\n    }\n  },\n\n  d3_defaultLocale: {\n    format,\n    formatPrefix\n  },\n\n  d3_defaultFormatSpecifier: \".01f\",\n\n  d3_defaultDelimiter: \"to\"\n}\n","import helper from \"./legend\"\nimport { dispatch } from \"d3-dispatch\"\nimport { scaleLinear } from \"d3-scale\"\nimport { formatLocale, formatSpecifier } from \"d3-format\"\n\nimport { sum } from \"d3-array\"\n\nexport default function color() {\n  let scale = scaleLinear(),\n    shape = \"rect\",\n    shapeWidth = 15,\n    shapeHeight = 15,\n    shapeRadius = 10,\n    shapePadding = 2,\n    cells = [5],\n    cellFilter,\n    labels = [],\n    classPrefix = \"\",\n    useClass = false,\n    title = \"\",\n    locale = helper.d3_defaultLocale,\n    specifier = helper.d3_defaultFormatSpecifier,\n    labelOffset = 10,\n    labelAlign = \"middle\",\n    labelDelimiter = helper.d3_defaultDelimiter,\n    labelWrap,\n    orient = \"vertical\",\n    ascending = false,\n    path,\n    titleWidth,\n    legendDispatcher = dispatch(\"cellover\", \"cellout\", \"cellclick\")\n\n  function legend(svg) {\n    const type = helper.d3_calcType(\n        scale,\n        ascending,\n        cells,\n        labels,\n        locale.format(specifier),\n        labelDelimiter\n      ),\n      legendG = svg.selectAll(\"g\").data([scale])\n\n    legendG\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", classPrefix + \"legendCells\")\n\n    if (cellFilter) {\n      helper.d3_filterCells(type, cellFilter)\n    }\n\n    let cell = svg\n      .select(\".\" + classPrefix + \"legendCells\")\n      .selectAll(\".\" + classPrefix + \"cell\")\n      .data(type.data)\n\n    const cellEnter = cell\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", classPrefix + \"cell\")\n    cellEnter.append(shape).attr(\"class\", classPrefix + \"swatch\")\n\n    let shapes = svg\n      .selectAll(\n        \"g.\" + classPrefix + \"cell \" + shape + \".\" + classPrefix + \"swatch\"\n      )\n      .data(type.data)\n\n    //add event handlers\n    helper.d3_addEvents(cellEnter, legendDispatcher)\n\n    cell\n      .exit()\n      .transition()\n      .style(\"opacity\", 0)\n      .remove()\n    shapes\n      .exit()\n      .transition()\n      .style(\"opacity\", 0)\n      .remove()\n\n    shapes = shapes.merge(shapes)\n\n    helper.d3_drawShapes(\n      shape,\n      shapes,\n      shapeHeight,\n      shapeWidth,\n      shapeRadius,\n      path\n    )\n    const text = helper.d3_addText(\n      svg,\n      cellEnter,\n      type.labels,\n      classPrefix,\n      labelWrap\n    )\n\n    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.\n    cell = cellEnter.merge(cell)\n\n    // sets placement\n    const textSize = text.nodes().map(d => d.getBBox()),\n      shapeSize = shapes.nodes().map(d => d.getBBox())\n    //sets scale\n    //everything is fill except for line which is stroke,\n    if (!useClass) {\n      if (shape == \"line\") {\n        shapes.style(\"stroke\", type.feature)\n      } else {\n        shapes.style(\"fill\", type.feature)\n      }\n    } else {\n      shapes.attr(\"class\", d => `${classPrefix}swatch ${type.feature(d)}`)\n    }\n\n    let cellTrans,\n      textTrans,\n      textAlign = labelAlign == \"start\" ? 0 : labelAlign == \"middle\" ? 0.5 : 1\n\n    //positions cells and text\n    if (orient === \"vertical\") {\n      const cellSize = textSize.map((d, i) =>\n        Math.max(d.height, shapeSize[i].height)\n      )\n\n      cellTrans = (d, i) => {\n        const height = sum(cellSize.slice(0, i))\n        return `translate(0, ${height + i * shapePadding})`\n      }\n\n      textTrans = (d, i) =>\n        `translate( ${shapeSize[i].width +\n          shapeSize[i].x +\n          labelOffset}, ${shapeSize[i].y + shapeSize[i].height / 2 + 5})`\n    } else if (orient === \"horizontal\") {\n      cellTrans = (d, i) =>\n        `translate(${i * (shapeSize[i].width + shapePadding)},0)`\n      textTrans = (d, i) => `translate(${shapeSize[i].width * textAlign +\n        shapeSize[i].x},\n          ${shapeSize[i].height + shapeSize[i].y + labelOffset + 8})`\n    }\n\n    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign)\n    helper.d3_title(svg, title, classPrefix, titleWidth)\n\n    cell.transition().style(\"opacity\", 1)\n  }\n\n  legend.scale = function(_) {\n    if (!arguments.length) return scale\n    scale = _\n    return legend\n  }\n\n  legend.cells = function(_) {\n    if (!arguments.length) return cells\n    if (_.length > 1 || _ >= 2) {\n      cells = _\n    }\n    return legend\n  }\n\n  legend.cellFilter = function(_) {\n    if (!arguments.length) return cellFilter\n    cellFilter = _\n    return legend\n  }\n\n  legend.shape = function(_, d) {\n    if (!arguments.length) return shape\n    if (\n      _ == \"rect\" ||\n      _ == \"circle\" ||\n      _ == \"line\" ||\n      (_ == \"path\" && typeof d === \"string\")\n    ) {\n      shape = _\n      path = d\n    }\n    return legend\n  }\n\n  legend.shapeWidth = function(_) {\n    if (!arguments.length) return shapeWidth\n    shapeWidth = +_\n    return legend\n  }\n\n  legend.shapeHeight = function(_) {\n    if (!arguments.length) return shapeHeight\n    shapeHeight = +_\n    return legend\n  }\n\n  legend.shapeRadius = function(_) {\n    if (!arguments.length) return shapeRadius\n    shapeRadius = +_\n    return legend\n  }\n\n  legend.shapePadding = function(_) {\n    if (!arguments.length) return shapePadding\n    shapePadding = +_\n    return legend\n  }\n\n  legend.labels = function(_) {\n    if (!arguments.length) return labels\n    labels = _\n    return legend\n  }\n\n  legend.labelAlign = function(_) {\n    if (!arguments.length) return labelAlign\n    if (_ == \"start\" || _ == \"end\" || _ == \"middle\") {\n      labelAlign = _\n    }\n    return legend\n  }\n\n  legend.locale = function(_) {\n    if (!arguments.length) return locale\n    locale = formatLocale(_)\n    return legend\n  }\n\n  legend.labelFormat = function(_) {\n    if (!arguments.length) return legend.locale().format(specifier)\n    specifier = formatSpecifier(_)\n    return legend\n  }\n\n  legend.labelOffset = function(_) {\n    if (!arguments.length) return labelOffset\n    labelOffset = +_\n    return legend\n  }\n\n  legend.labelDelimiter = function(_) {\n    if (!arguments.length) return labelDelimiter\n    labelDelimiter = _\n    return legend\n  }\n\n  legend.labelWrap = function(_) {\n    if (!arguments.length) return labelWrap\n    labelWrap = _\n    return legend\n  }\n\n  legend.useClass = function(_) {\n    if (!arguments.length) return useClass\n    if (_ === true || _ === false) {\n      useClass = _\n    }\n    return legend\n  }\n\n  legend.orient = function(_) {\n    if (!arguments.length) return orient\n    _ = _.toLowerCase()\n    if (_ == \"horizontal\" || _ == \"vertical\") {\n      orient = _\n    }\n    return legend\n  }\n\n  legend.ascending = function(_) {\n    if (!arguments.length) return ascending\n    ascending = !!_\n    return legend\n  }\n\n  legend.classPrefix = function(_) {\n    if (!arguments.length) return classPrefix\n    classPrefix = _\n    return legend\n  }\n\n  legend.title = function(_) {\n    if (!arguments.length) return title\n    title = _\n    return legend\n  }\n\n  legend.titleWidth = function(_) {\n    if (!arguments.length) return titleWidth\n    titleWidth = _\n    return legend\n  }\n\n  legend.textWrap = function(_) {\n    if (!arguments.length) return textWrap\n    textWrap = _\n    return legend\n  }\n\n  legend.on = function() {\n    const value = legendDispatcher.on.apply(legendDispatcher, arguments)\n    return value === legendDispatcher ? legend : value\n  }\n\n  return legend\n}\n","import helper from \"./legend\"\nimport { dispatch } from \"d3-dispatch\"\nimport { scaleLinear } from \"d3-scale\"\nimport { formatLocale, formatSpecifier } from \"d3-format\"\nimport { sum, max } from \"d3-array\"\n\nexport default function size() {\n  let scale = scaleLinear(),\n    shape = \"rect\",\n    shapeWidth = 15,\n    shapePadding = 2,\n    cells = [5],\n    cellFilter,\n    labels = [],\n    classPrefix = \"\",\n    title = \"\",\n    locale = helper.d3_defaultLocale,\n    specifier = helper.d3_defaultFormatSpecifier,\n    labelOffset = 10,\n    labelAlign = \"middle\",\n    labelDelimiter = helper.d3_defaultDelimiter,\n    labelWrap,\n    orient = \"vertical\",\n    ascending = false,\n    path,\n    titleWidth,\n    legendDispatcher = dispatch(\"cellover\", \"cellout\", \"cellclick\")\n\n  function legend(svg) {\n    const type = helper.d3_calcType(\n        scale,\n        ascending,\n        cells,\n        labels,\n        locale.format(specifier),\n        labelDelimiter\n      ),\n      legendG = svg.selectAll(\"g\").data([scale])\n\n    if (cellFilter) {\n      helper.d3_filterCells(type, cellFilter)\n    }\n\n    legendG\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", classPrefix + \"legendCells\")\n\n    let cell = svg\n      .select(\".\" + classPrefix + \"legendCells\")\n      .selectAll(\".\" + classPrefix + \"cell\")\n      .data(type.data)\n    const cellEnter = cell\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", classPrefix + \"cell\")\n    cellEnter.append(shape).attr(\"class\", classPrefix + \"swatch\")\n\n    let shapes = svg.selectAll(\n      \"g.\" + classPrefix + \"cell \" + shape + \".\" + classPrefix + \"swatch\"\n    )\n\n    //add event handlers\n    helper.d3_addEvents(cellEnter, legendDispatcher)\n\n    cell\n      .exit()\n      .transition()\n      .style(\"opacity\", 0)\n      .remove()\n\n    shapes\n      .exit()\n      .transition()\n      .style(\"opacity\", 0)\n      .remove()\n    shapes = shapes.merge(shapes)\n\n    //creates shape\n    if (shape === \"line\") {\n      helper.d3_drawShapes(shape, shapes, 0, shapeWidth)\n      shapes.attr(\"stroke-width\", type.feature)\n    } else {\n      helper.d3_drawShapes(\n        shape,\n        shapes,\n        type.feature,\n        type.feature,\n        type.feature,\n        path\n      )\n    }\n\n    const text = helper.d3_addText(\n      svg,\n      cellEnter,\n      type.labels,\n      classPrefix,\n      labelWrap\n    )\n\n    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.\n    cell = cellEnter.merge(cell)\n\n    //sets placement\n\n    const textSize = text.nodes().map(d => d.getBBox()),\n      shapeSize = shapes.nodes().map((d, i) => {\n        const bbox = d.getBBox()\n        const stroke = scale(type.data[i])\n\n        if (shape === \"line\" && orient === \"horizontal\") {\n          bbox.height = bbox.height + stroke\n        } else if (shape === \"line\" && orient === \"vertical\") {\n          bbox.width = bbox.width\n        }\n        return bbox\n      })\n\n    const maxH = max(shapeSize, d => d.height + d.y),\n      maxW = max(shapeSize, d => d.width + d.x)\n\n    let cellTrans,\n      textTrans,\n      textAlign = labelAlign == \"start\" ? 0 : labelAlign == \"middle\" ? 0.5 : 1\n\n    //positions cells and text\n    if (orient === \"vertical\") {\n      const cellSize = textSize.map((d, i) =>\n        Math.max(d.height, shapeSize[i].height)\n      )\n      const y =\n        shape == \"circle\" || shape == \"line\" ? shapeSize[0].height / 2 : 0\n      cellTrans = (d, i) => {\n        const height = sum(cellSize.slice(0, i))\n\n        return `translate(0, ${y + height + i * shapePadding})`\n      }\n\n      textTrans = (d, i) => `translate( ${maxW + labelOffset},\n          ${shapeSize[i].y + shapeSize[i].height / 2 + 5})`\n    } else if (orient === \"horizontal\") {\n      cellTrans = (d, i) => {\n        const width = sum(shapeSize.slice(0, i), d => d.width)\n        const y = shape == \"circle\" || shape == \"line\" ? maxH / 2 : 0\n        return `translate(${width + i * shapePadding}, ${y})`\n      }\n\n      const offset = shape == \"line\" ? maxH / 2 : maxH\n      textTrans = (d, i) => {\n        return `translate( ${shapeSize[i].width * textAlign + shapeSize[i].x},\n              ${offset + labelOffset})`\n      }\n    }\n\n    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign)\n    helper.d3_title(svg, title, classPrefix, titleWidth)\n\n    cell.transition().style(\"opacity\", 1)\n  }\n\n  legend.scale = function(_) {\n    if (!arguments.length) return scale\n    scale = _\n    return legend\n  }\n\n  legend.cells = function(_) {\n    if (!arguments.length) return cells\n    if (_.length > 1 || _ >= 2) {\n      cells = _\n    }\n    return legend\n  }\n\n  legend.cellFilter = function(_) {\n    if (!arguments.length) return cellFilter\n    cellFilter = _\n    return legend\n  }\n\n  legend.shape = function(_, d) {\n    if (!arguments.length) return shape\n    if (_ == \"rect\" || _ == \"circle\" || _ == \"line\") {\n      shape = _\n      path = d\n    }\n    return legend\n  }\n\n  legend.shapeWidth = function(_) {\n    if (!arguments.length) return shapeWidth\n    shapeWidth = +_\n    return legend\n  }\n\n  legend.shapePadding = function(_) {\n    if (!arguments.length) return shapePadding\n    shapePadding = +_\n    return legend\n  }\n\n  legend.labels = function(_) {\n    if (!arguments.length) return labels\n    labels = _\n    return legend\n  }\n\n  legend.labelAlign = function(_) {\n    if (!arguments.length) return labelAlign\n    if (_ == \"start\" || _ == \"end\" || _ == \"middle\") {\n      labelAlign = _\n    }\n    return legend\n  }\n\n  legend.locale = function(_) {\n    if (!arguments.length) return locale\n    locale = formatLocale(_)\n    return legend\n  }\n\n  legend.labelFormat = function(_) {\n    if (!arguments.length) return legend.locale().format(specifier)\n    specifier = formatSpecifier(_)\n    return legend\n  }\n\n  legend.labelOffset = function(_) {\n    if (!arguments.length) return labelOffset\n    labelOffset = +_\n    return legend\n  }\n\n  legend.labelDelimiter = function(_) {\n    if (!arguments.length) return labelDelimiter\n    labelDelimiter = _\n    return legend\n  }\n\n  legend.labelWrap = function(_) {\n    if (!arguments.length) return labelWrap\n    labelWrap = _\n    return legend\n  }\n\n  legend.orient = function(_) {\n    if (!arguments.length) return orient\n    _ = _.toLowerCase()\n    if (_ == \"horizontal\" || _ == \"vertical\") {\n      orient = _\n    }\n    return legend\n  }\n\n  legend.ascending = function(_) {\n    if (!arguments.length) return ascending\n    ascending = !!_\n    return legend\n  }\n\n  legend.classPrefix = function(_) {\n    if (!arguments.length) return classPrefix\n    classPrefix = _\n    return legend\n  }\n\n  legend.title = function(_) {\n    if (!arguments.length) return title\n    title = _\n    return legend\n  }\n\n  legend.titleWidth = function(_) {\n    if (!arguments.length) return titleWidth\n    titleWidth = _\n    return legend\n  }\n\n  legend.on = function() {\n    const value = legendDispatcher.on.apply(legendDispatcher, arguments)\n    return value === legendDispatcher ? legend : value\n  }\n\n  return legend\n}\n","import helper from \"./legend\"\nimport { dispatch } from \"d3-dispatch\"\nimport { scaleLinear } from \"d3-scale\"\nimport { formatLocale, formatSpecifier } from \"d3-format\"\nimport { sum, max } from \"d3-array\"\n\nexport default function symbol() {\n  let scale = scaleLinear(),\n    shape = \"path\",\n    shapeWidth = 15,\n    shapeHeight = 15,\n    shapeRadius = 10,\n    shapePadding = 5,\n    cells = [5],\n    cellFilter,\n    labels = [],\n    classPrefix = \"\",\n    title = \"\",\n    locale = helper.d3_defaultLocale,\n    specifier = helper.d3_defaultFormatSpecifier,\n    labelAlign = \"middle\",\n    labelOffset = 10,\n    labelDelimiter = helper.d3_defaultDelimiter,\n    labelWrap,\n    orient = \"vertical\",\n    ascending = false,\n    titleWidth,\n    legendDispatcher = dispatch(\"cellover\", \"cellout\", \"cellclick\")\n\n  function legend(svg) {\n    const type = helper.d3_calcType(\n        scale,\n        ascending,\n        cells,\n        labels,\n        locale.format(specifier),\n        labelDelimiter\n      ),\n      legendG = svg.selectAll(\"g\").data([scale])\n\n    if (cellFilter) {\n      helper.d3_filterCells(type, cellFilter)\n    }\n\n    legendG\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", classPrefix + \"legendCells\")\n\n    let cell = svg\n      .select(\".\" + classPrefix + \"legendCells\")\n      .selectAll(\".\" + classPrefix + \"cell\")\n      .data(type.data)\n    const cellEnter = cell\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", classPrefix + \"cell\")\n    cellEnter.append(shape).attr(\"class\", classPrefix + \"swatch\")\n\n    let shapes = svg.selectAll(\"g.\" + classPrefix + \"cell \" + shape + \".\" + classPrefix + \"swatch\")\n\n    //add event handlers\n    helper.d3_addEvents(cellEnter, legendDispatcher)\n\n    //remove old shapes\n    cell\n      .exit()\n      .transition()\n      .style(\"opacity\", 0)\n      .remove()\n    shapes\n      .exit()\n      .transition()\n      .style(\"opacity\", 0)\n      .remove()\n    shapes = shapes.merge(shapes)\n\n    helper.d3_drawShapes(\n      shape,\n      shapes,\n      shapeHeight,\n      shapeWidth,\n      shapeRadius,\n      type.feature\n    )\n    const text = helper.d3_addText(\n      svg,\n      cellEnter,\n      type.labels,\n      classPrefix,\n      labelWrap\n    )\n\n    // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.\n    cell = cellEnter.merge(cell)\n\n    // sets placement\n    const textSize = text.nodes().map(d => d.getBBox()),\n      shapeSize = shapes.nodes().map(d => d.getBBox())\n\n    const maxH = max(shapeSize, d => d.height),\n      maxW = max(shapeSize, d => d.width)\n\n    let cellTrans,\n      textTrans,\n      textAlign = labelAlign == \"start\" ? 0 : labelAlign == \"middle\" ? 0.5 : 1\n\n    //positions cells and text\n    if (orient === \"vertical\") {\n      const cellSize = textSize.map((d, i) => Math.max(maxH, d.height))\n\n      cellTrans = (d, i) => {\n        const height = sum(cellSize.slice(0, i))\n        return `translate(0, ${height + i * shapePadding} )`\n      }\n      textTrans = (d, i) => `translate( ${maxW + labelOffset},\n              ${shapeSize[i].y + shapeSize[i].height / 2 + 5})`\n    } else if (orient === \"horizontal\") {\n      cellTrans = (d, i) => `translate( ${i * (maxW + shapePadding)},0)`\n      textTrans = (d, i) => `translate( ${shapeSize[i].width * textAlign +\n        shapeSize[i].x},\n              ${maxH + labelOffset})`\n    }\n\n    helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign)\n    helper.d3_title(svg, title, classPrefix, titleWidth)\n    cell.transition().style(\"opacity\", 1)\n  }\n\n  legend.scale = function(_) {\n    if (!arguments.length) return scale\n    scale = _\n    return legend\n  }\n\n  legend.cells = function(_) {\n    if (!arguments.length) return cells\n    if (_.length > 1 || _ >= 2) {\n      cells = _\n    }\n    return legend\n  }\n\n  legend.cellFilter = function(_) {\n    if (!arguments.length) return cellFilter\n    cellFilter = _\n    return legend\n  }\n\n  legend.shapePadding = function(_) {\n    if (!arguments.length) return shapePadding\n    shapePadding = +_\n    return legend\n  }\n\n  legend.labels = function(_) {\n    if (!arguments.length) return labels\n    labels = _\n    return legend\n  }\n\n  legend.labelAlign = function(_) {\n    if (!arguments.length) return labelAlign\n    if (_ == \"start\" || _ == \"end\" || _ == \"middle\") {\n      labelAlign = _\n    }\n    return legend\n  }\n\n  legend.locale = function(_) {\n    if (!arguments.length) return locale\n    locale = formatLocale(_)\n    return legend\n  }\n\n  legend.labelFormat = function(_) {\n    if (!arguments.length) return legend.locale().format(specifier)\n    specifier = formatSpecifier(_)\n    return legend\n  }\n\n  legend.labelOffset = function(_) {\n    if (!arguments.length) return labelOffset\n    labelOffset = +_\n    return legend\n  }\n\n  legend.labelDelimiter = function(_) {\n    if (!arguments.length) return labelDelimiter\n    labelDelimiter = _\n    return legend\n  }\n\n  legend.labelWrap = function(_) {\n    if (!arguments.length) return labelWrap\n    labelWrap = _\n    return legend\n  }\n\n  legend.orient = function(_) {\n    if (!arguments.length) return orient\n    _ = _.toLowerCase()\n    if (_ == \"horizontal\" || _ == \"vertical\") {\n      orient = _\n    }\n    return legend\n  }\n\n  legend.ascending = function(_) {\n    if (!arguments.length) return ascending\n    ascending = !!_\n    return legend\n  }\n\n  legend.classPrefix = function(_) {\n    if (!arguments.length) return classPrefix\n    classPrefix = _\n    return legend\n  }\n\n  legend.title = function(_) {\n    if (!arguments.length) return title\n    title = _\n    return legend\n  }\n\n  legend.titleWidth = function(_) {\n    if (!arguments.length) return titleWidth\n    titleWidth = _\n    return legend\n  }\n\n  legend.on = function() {\n    const value = legendDispatcher.on.apply(legendDispatcher, arguments)\n    return value === legendDispatcher ? legend : value\n  }\n\n  return legend\n}\n","export const thresholdLabels = function({\n  i,\n  genLength,\n  generatedLabels,\n  labelDelimiter\n}) {\n  if (i === 0) {\n    const values = generatedLabels[i].split(` ${labelDelimiter} `)\n    return `Less than ${values[1]}`\n  } else if (i === genLength - 1) {\n    const values = generatedLabels[i].split(` ${labelDelimiter} `)\n    return `${values[0]} or more`\n  }\n  return generatedLabels[i]\n}\n\nexport default {\n  thresholdLabels\n}\n","import legendColor from './src/color'\nimport legendSize from './src/size'\nimport legendSymbol from './src/symbol'\nimport legendHelpers from './src/helpers'\n\nexport { legendColor, legendSize, legendSymbol, legendHelpers }\n\nexport default {\n  legendColor,\n  legendSize,\n  legendSymbol,\n  legendHelpers\n};\n"]},"metadata":{},"sourceType":"module"}